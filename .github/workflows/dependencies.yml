name: Dependency Management

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  schedule:
    # Check dependencies daily at 6 AM UTC
    - cron: '0 6 * * *'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  security-events: write

env:
  APP_NAME: sast-readium

jobs:
  # Check for outdated dependencies
  dependency-update-check:
    name: Check for Dependency Updates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependency checking tools
        run: |
          pip install --upgrade pip
          pip install requests packaging

      - name: Check vcpkg Dependencies
        run: |
          echo "## vcpkg Dependency Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "vcpkg.json" ]; then
            echo "### Current vcpkg Dependencies" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            python3 -c "
import json
from datetime import datetime
import requests

def check_vcpkg_package(package_name):
    \"\"\"Check latest version of vcpkg package\"\"\"
    try:
        # Try to get version from vcpkg registry (simplified)
        url = f'https://registry.vcpkg.org/packages/{package_name}/versions'
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            data = response.json()
            if data and len(data) > 0:
                return data[-1]['version']  # Get latest version
    except:
        pass
    return None

try:
    with open('vcpkg.json', 'r') as f:
        data = json.load(f)

    deps = data.get('dependencies', [])
    print('| Package | Version Constraint | Latest Version | Update Available |')
    print('|---------|-------------------|----------------|------------------|')

    for dep in deps:
        if isinstance(dep, str):
            package_name = dep
            version_constraint = 'latest'
        elif isinstance(dep, dict):
            package_name = dep.get('name', 'unknown')
            version_spec = dep.get('version>=')
            version_constraint = version_spec if version_spec else 'latest'
        else:
            continue

        latest_version = check_vcpkg_package(package_name)
        update_available = '✅ Yes' if latest_version and latest_version != version_constraint else '❌ No'

        print(f'| {package_name} | {version_constraint} | {latest_version or \"N/A\"} | {update_available} |')

except Exception as e:
    print(f'Error analyzing vcpkg.json: {e}')
" >> $GITHUB_STEP_SUMMARY

          else
            echo "✅ Using system packages (no vcpkg.json found)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check System Package Dependencies
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## System Package Dependencies" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check for system package information based on CMakeLists.txt
          echo "### Required System Libraries" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "CMakeLists.txt" ]; then
            echo "**Dependencies identified from CMakeLists.txt:**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            grep -i "find_package" CMakeLists.txt | grep -v "^#" | head -10 | while read line; do
              package=$(echo "$line" | sed -n 's/.*find_package[[:space:]]*([[:space:]]*\([^[:space:]]*\).*/\1/p')
              if [ -n "$package" ]; then
                echo "- $package" >> $GITHUB_STEP_SUMMARY
              fi
            done
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### System Package Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check key dependencies
          for package in qt6-base-dev qt6-svg-dev libpoppler-qt6-dev; do
            if dpkg -l | grep -q "$package"; then
              VERSION=$(dpkg -l | grep "$package" | awk '{print $3}')
              echo "- ✅ $package: $VERSION" >> $GITHUB_STEP_SUMMARY
            else
              echo "- ❌ $package: Not found" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Update Recommendations" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Regular system updates: \`sudo apt update && sudo apt upgrade\`" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor Qt6 release notes for breaking changes" >> $GITHUB_STEP_SUMMARY
          echo "- Track Poppler security updates" >> $GITHUB_STEP_SUMMARY

      - name: Check Python Dependencies
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Python Dependencies" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Look for Python dependency files
          if find . -name "requirements*.txt" -o -name "setup.py" -o -name "pyproject.toml" | head -1; then
            echo "### Python Dependencies Found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            find . -name "requirements*.txt" -o -name "setup.py" -o -name "pyproject.toml" | while read file; do
              echo "- $file" >> $GITHUB_STEP_SUMMARY
            done

            # Check for outdated packages if requirements.txt exists
            if [ -f "requirements.txt" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### Package Versions" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              pip install --dry-run -r requirements.txt 2>/dev/null | grep -E "Collecting|Would install" | head -20 >> $GITHUB_STEP_SUMMARY || echo "Could not analyze package versions" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "✅ No Python dependencies found" >> $GITHUB_STEP_SUMMARY
          fi

  # License compliance checking
  license-compliance:
    name: License Compliance Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install license checking tools
        run: |
          pip install --upgrade pip
          pip install requests beautifulsoup4

      - name: Analyze Dependency Licenses
        run: |
          echo "## License Compliance Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create license analysis script
          cat > analyze_licenses.py << 'EOF'
import json
import re
from urllib.parse import quote

# License categories for compliance
APPROVED_LICENSES = [
    'MIT', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause',
    'LGPL-2.1', 'LGPL-3.0', 'GPL-2.0', 'GPL-3.0',
    'Boost-1.0', 'ISC', 'Unlicense', 'CC0-1.0'
]

REVIEW_REQUIRED_LICENSES = [
    'AGPL-3.0', 'SSPL', 'BSL-1.0', 'EUPL-1.2'
]

def analyze_vcpkg_licenses():
    """Analyze vcpkg dependency licenses"""
    if not os.path.exists('vcpkg.json'):
        return []

    try:
        with open('vcpkg.json', 'r') as f:
            data = json.load(f)

        deps = data.get('dependencies', [])
        license_info = []

        for dep in deps:
            if isinstance(dep, str):
                package_name = dep
            elif isinstance(dep, dict):
                package_name = dep.get('name', '')
            else:
                continue

            # Common vcpkg package licenses (simplified mapping)
            known_licenses = {
                'qt6-base': 'LGPL-3.0',
                'qt6-svg': 'LGPL-3.0',
                'qt6-tools': 'LGPL-3.0',
                'poppler': 'GPL-2.0',
                'openssl': 'Apache-2.0',
                'zlib': 'Zlib',
                'freetype': 'FTL',
                'harfbuzz': 'MIT',
                'icu': 'ICU',
                'libpng': 'libpng-2.0',
                'libjpeg-turbo': 'IJG',
                'libtiff': 'libtiff'
            }

            license_name = known_licenses.get(package_name, 'Unknown')
            compliance = 'Approved' if license_name in APPROVED_LICENSES else 'Review Required'

            license_info.append({
                'package': package_name,
                'license': license_name,
                'compliance': compliance
            })

        return license_info
    except Exception as e:
        print(f"Error analyzing vcpkg licenses: {e}")
        return []

def analyze_system_licenses():
    """Analyze system package licenses"""
    system_packages = [
        ('qt6-base-dev', 'LGPL-3.0'),
        ('qt6-svg-dev', 'LGPL-3.0'),
        ('qt6-tools-dev', 'LGPL-3.0'),
        ('libpoppler-qt6-dev', 'GPL-2.0'),
        ('cmake', 'BSD-3-Clause'),
        ('ninja-build', 'Apache-2.0')
    ]

    license_info = []
    for package, license_name in system_packages:
        compliance = 'Approved' if license_name in APPROVED_LICENSES else 'Review Required'
        license_info.append({
            'package': package,
            'license': license_name,
            'compliance': compliance,
            'type': 'System Package'
        })

    return license_info

def main():
    import os

    print("### License Compliance Summary")
    print("")
    print("| Package | License | Type | Compliance |")
    print("|---------|---------|------|------------|")

    all_licenses = analyze_vcpkg_licenses() + analyze_system_licenses()

    approved_count = 0
    review_count = 0

    for info in all_licenses:
        package = info.get('package', 'Unknown')
        license_name = info.get('license', 'Unknown')
        package_type = info.get('type', 'vcpkg')
        compliance = info.get('compliance', 'Review Required')

        if compliance == 'Approved':
            approved_count += 1
        else:
            review_count += 1

        status_emoji = '✅' if compliance == 'Approved' else '⚠️'
        print(f"| {package} | {license_name} | {package_type} | {status_emoji} {compliance} |")

    print("")
    print(f"**Summary:** {approved_count} approved licenses, {review_count} require review")
    print("")

    if review_count > 0:
        print("### Action Required")
        print("")
        print("⚠️ The following packages require license review:")
        for info in all_licenses:
            if info.get('compliance') == 'Review Required':
                print(f"- {info.get('package')} ({info.get('license')})")
        print("")
        print("Please review these licenses to ensure compliance with your project's licensing policy.")
    else:
        print("✅ All dependencies have approved licenses")

if __name__ == "__main__":
    main()
EOF

          python3 analyze_licenses.py >> $GITHUB_STEP_SUMMARY

  # Dependency vulnerability scanning
  vulnerability-scan:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install vulnerability scanning tools
        run: |
          pip install --upgrade pip
          pip install safety requests

      - name: Run Safety Check for Python Dependencies
        run: |
          echo "## Python Dependency Vulnerability Scan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "requirements.txt" ]; then
            echo "### Safety Scan Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Run safety check
            safety check --json --output safety-report.json || true
            safety check --output safety-report.txt || true

            # Parse results
            if [ -f "safety-report.json" ]; then
                python3 -c "
import json
try:
    with open('safety-report.json', 'r') as f:
        data = json.load(f)
    vulns = data.get('vulnerabilities', [])
    if vulns:
        print(f'⚠️ Found {len(vulns)} vulnerabilities:')
        for vuln in vulns:
            package = vuln.get('package_name', 'Unknown')
            version = vuln.get('vulnerable_spec', 'Unknown')
            cve = vuln.get('cve', 'No CVE')
            advisory = vuln.get('advisory', 'No details available')
            print(f'- **{package}** ({version}): {cve}')
            print(f'  - {advisory}')
    else:
        print('✅ No Python vulnerabilities found')
except Exception as e:
    print(f'Error processing safety report: {e}')
" >> $GITHUB_STEP_SUMMARY
            else
              echo "Could not run safety scan" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "✅ No Python dependencies to scan" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check C++ Dependency Vulnerabilities
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## C++ Dependency Vulnerability Scan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create C++ vulnerability checker
          cat > check_cpp_vulns.py << 'EOF'
import requests
import json

# Known vulnerable versions for key C++ dependencies
VULNERABLE_VERSIONS = {
    'openssl': {
        'vulnerable': ['1.1.1n', '1.1.1o', '1.1.1p'],
        'secure': '3.0.0+',
        'description': 'Multiple security vulnerabilities'
    },
    'poppler': {
        'vulnerable': ['22.0.0', '22.1.0', '22.2.0'],
        'secure': '23.0.0+',
        'description': 'PDF parsing vulnerabilities'
    },
    'qt': {
        'vulnerable': ['6.2.0', '6.2.1', '6.3.0'],
        'secure': '6.5.0+',
        'description': 'Various security fixes in newer versions'
    }
}

def check_package_vulnerabilities(package_name, current_version):
    """Check if a package version has known vulnerabilities"""
    vuln_info = VULNERABLE_VERSIONS.get(package_name.lower())
    if not vuln_info:
        return None

    if current_version in vuln_info['vulnerable']:
        return {
            'vulnerable': True,
            'package': package_name,
            'version': current_version,
            'secure_version': vuln_info['secure'],
            'description': vuln_info['description']
        }

    return None

def main():
    print("### C++ Library Security Status")
    print("")
    print("| Library | Current Version | Secure Version | Status |")
    print("|---------|----------------|----------------|--------|")

    # Check key dependencies (simplified version detection)
    key_packages = ['OpenSSL', 'Poppler', 'Qt']

    for package in key_packages:
        # In a real implementation, you would detect actual versions
        # For now, we'll provide guidance
        print(f"| {package} | Check manually | See documentation | ⚠️ Verify manually |")

    print("")
    print("### Security Recommendations")
    print("")
    print("- **OpenSSL**: Use version 3.0.0 or newer")
    print("- **Poppler**: Use version 23.0.0 or newer")
    print("- **Qt6**: Use version 6.5.0 or newer")
    print("- Regularly check security advisories for all dependencies")
    print("- Subscribe to security mailing lists for critical updates")

if __name__ == "__main__":
    main()
EOF

          python3 check_cpp_vulns.py >> $GITHUB_STEP_SUMMARY

      - name: Upload Security Reports
        uses: actions/upload-artifact@v4
        with:
          name: dependency-security-reports
          path: |
            safety-report.json
            safety-report.txt
            check_cpp_vulns.py
          retention-days: 30

  # Dependency updates automation
  dependency-update-pr:
    name: Create Dependency Update PR
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' && github.ref == 'refs/heads/master'
    needs: [dependency-update-check, vulnerability-scan]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Create Dependency Update Branch
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git checkout -b chore/dependency-updates

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Generate Update Report
        run: |
          echo "# Dependency Update Report" > dependency-updates.md
          echo "" >> dependency-updates.md
          echo "Generated on: $(date)" >> dependency-updates.md
          echo "" >> dependency-updates.md
          echo "## Automated Dependency Analysis" >> dependency-updates.md
          echo "" >> dependency-updates.md
          echo "This PR was created automatically to highlight dependency updates." >> dependency-updates.md
          echo "" >> dependency-updates.md
          echo "### Manual Update Steps" >> dependency-updates.md
          echo "" >> dependency-updates.md
          echo "1. Review the security and performance reports from the latest workflow run" >> dependency-updates.md
          echo "2. Update system packages: \`sudo apt update && sudo apt upgrade\`" >> dependency-updates.md
          echo "3. Update vcpkg packages: \`vcpkg upgrade\`" >> dependency-updates.md
          echo "4. Update Python packages: \`pip install --upgrade -r requirements.txt\`" >> dependency-updates.md
          echo "5. Test all changes thoroughly" >> dependency-updates.md
          echo "" >> dependency-updates.md
          echo "### Security Considerations" >> dependency-updates.md
          echo "" >> dependency-updates.md
          echo "- Always review security advisories before updating" >> dependency-updates.md
          echo "- Test updates in a development environment first" >> dependency-updates.md
          echo "- Monitor for breaking changes in major version updates" >> dependency-updates.md

      - name: Commit Update Report
        run: |
          git add dependency-updates.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: Add dependency update report"
            git push origin chore/dependency-updates --force
          fi

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: chore/dependency-updates
          title: "chore: Automated dependency update report"
          body: |
            ## Automated Dependency Update Report

            This PR was created automatically by the dependency management workflow.

            ### What's included:
            - Dependency update analysis and recommendations
            - Security vulnerability scan results
            - License compliance report

            ### Next steps:
            1. Review the reports in the workflow runs
            2. Manually update dependencies as needed
            3. Test changes thoroughly
            4. Update this PR with any additional changes

            **Note:** This is a reminder to check and update dependencies. Actual dependency updates should be performed manually after proper testing.
          draft: false
          delete-branch: true
