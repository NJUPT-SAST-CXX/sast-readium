---
globs: *.cpp,*.h,*.ui,*.qrc
description: Qt-specific patterns and best practices for SAST Readium
---

# Qt Framework Patterns for SAST Readium

## Qt Version

This project uses **Qt6**. All code must be compatible with Qt6 APIs.

## Object Model

### QObject Hierarchy
- Leverage Qt's parent-child ownership for automatic memory management
- Set parent in constructor or immediately after creation
- Child objects are automatically deleted when parent is destroyed

### Q_OBJECT Macro
- **Always** include `Q_OBJECT` macro in classes that inherit from QObject
- Required for signals/slots, properties, and meta-object features
- Place at the beginning of the class definition

### Meta-Object Compiler (MOC)
- Header files with `Q_OBJECT` must be processed by MOC
- Include generated `.moc` file at end of `.cpp` for classes defined in source files:
  ```cpp
  #include "my_class.moc"
  ```

## Signals and Slots

### Modern Connection Syntax
- **Always** use function pointer syntax (Qt5+ style):
  ```cpp
  connect(sender, &Sender::signalName, receiver, &Receiver::slotName);
  ```
- Avoid old string-based syntax (`SIGNAL()`, `SLOT()`)

### Lambda Connections
- Use lambdas for inline slot logic:
  ```cpp
  connect(button, &QPushButton::clicked, this, [this]() {
      handleButtonClick();
  });
  ```
- Capture `this` carefully in lambdas to avoid dangling pointers
- Use `QPointer` or disconnect in destructor for long-lived connections

### Signal Design
- Signals should be `public` or `signals:` section
- Don't implement signal bodies (generated by MOC)
- Signal names should describe events, not actions: `documentOpened`, `pageChanged`
- Pass const references for complex types:
  ```cpp
  signals:
      void documentOpened(const QString& fileName);
      void searchCompleted(const QList<Result>& results);
  ```

### Slot Design
- Slots can be public, protected, or private based on visibility needs
- Keep slots lightweight; delegate heavy work to background threads
- Always check sender validity with `QPointer` when needed

### Connection Management
- Disconnect signals in destructor if object lifetime is uncertain
- Store `QMetaObject::Connection` for manual disconnection:
  ```cpp
  m_connection = connect(...);
  // Later: disconnect(m_connection);
  ```
- Use `Qt::UniqueConnection` to prevent duplicate connections

## Widget Patterns

### Widget Lifecycle
- Create widgets with parent to ensure cleanup
- Use `deleteLater()` instead of `delete` for widgets in event handlers
- Check widget validity with `QPointer<QWidget>` for delayed access

### Custom Widgets
- Inherit from appropriate base: `QWidget`, `QDialog`, `QMainWindow`
- Override `paintEvent()` for custom drawing
- Override `sizeHint()` and `minimumSizeHint()` for layout integration
- Call base class implementation in overridden event handlers

### Layout Management
- Always use layouts for widget positioning (never fixed coordinates)
- Common layouts: `QVBoxLayout`, `QHBoxLayout`, `QGridLayout`, `QStackedLayout`
- Set layout with `setLayout()` or pass parent to layout constructor
- Use spacers (`QSpacerItem`) for flexible spacing

### Example from MainWindow
See [MainWindow.cpp](mdc:app/MainWindow.cpp) and [MainWindow.h](mdc:app/MainWindow.h) for widget organization patterns.

## Model/View Framework

### Model Design
- Inherit from `QAbstractItemModel`, `QAbstractListModel`, or `QAbstractTableModel`
- Implement required methods: `rowCount()`, `data()`, `index()`, `parent()`
- Emit signals for data changes: `dataChanged()`, `rowsInserted()`, `rowsRemoved()`
- Use `beginInsertRows()`, `endInsertRows()`, etc. for structure changes

### View Configuration
- Use standard views: `QListView`, `QTableView`, `QTreeView`
- Set model with `setModel()`
- Customize with delegates: inherit from `QStyledItemDelegate` or `QAbstractItemDelegate`
- Example: [ThumbnailDelegate](mdc:app/delegate/ThumbnailDelegate.h) for custom thumbnail rendering

### Delegate Patterns
- Override `paint()` for custom item rendering
- Override `sizeHint()` for custom item sizes
- Override `createEditor()`, `setEditorData()`, `setModelData()` for custom editing
- Use QPainter for efficient drawing

## Resource Management

### Qt Resource System (.qrc)
- Store images, icons, stylesheets in resource files
- Reference with `:` prefix: `:/icons/app_icon.svg`
- See [app.qrc](mdc:app/app.qrc) for project resources
- Compile-time bundling ensures resources are always available

### Icons and Images
- Use SVG for scalable icons
- Use `QIcon::fromTheme()` for system icons when available
- Cache loaded images to avoid repeated loading
- Use `QPixmap` for display, `QImage` for manipulation

### Stylesheets
- Use Qt Style Sheets (QSS) for UI theming
- Load from resources or files: `app->setStyleSheet(styleContent)`
- See [assets/styles/](mdc:assets/styles/) for project stylesheets
- Follow CSS-like syntax for selectors and properties

## Threading in Qt

### QThread
- Inherit from `QObject`, move to `QThread` with `moveToThread()`
- **Don't** inherit from `QThread` unless reimplementing `run()`
- Use signals/slots for thread communication (queued connections)

### Worker Object Pattern
```cpp
// Worker object
class Worker : public QObject {
    Q_OBJECT
public slots:
    void doWork() {
        // Heavy computation
        emit resultReady(result);
    }
signals:
    void resultReady(const Result& result);
};

// Usage
QThread* thread = new QThread;
Worker* worker = new Worker;
worker->moveToThread(thread);
connect(thread, &QThread::finished, worker, &QObject::deleteLater);
connect(this, &Controller::operate, worker, &Worker::doWork);
connect(worker, &Worker::resultReady, this, &Controller::handleResult);
thread->start();
```

### QtConcurrent
- Use for parallel operations: `QtConcurrent::run()`, `QtConcurrent::map()`, etc.
- Returns `QFuture` for result retrieval
- Use `QFutureWatcher` for progress monitoring

### Thread-Safe Communication
- Signals/slots between threads are automatically queued (thread-safe)
- Use `Qt::DirectConnection` only for same-thread calls
- Use `Qt::BlockingQueuedConnection` carefully (can deadlock)

## Event System

### Event Handling
- Override event handlers: `event()`, `mousePressEvent()`, `keyPressEvent()`, etc.
- Call base implementation: `QWidget::event(event)` unless consuming event
- Return `true` if event is handled, `false` to propagate

### Custom Events
- Inherit from `QEvent` with unique event type
- Post events: `QCoreApplication::postEvent(receiver, event)`
- Send events: `QCoreApplication::sendEvent(receiver, event)`

### Event Bus Pattern
- Project uses custom EventBus for application-wide events
- See [EventBus](mdc:app/controller/EventBus.h) for implementation
- Prefer EventBus over direct signal/slot for decoupled communication

## File I/O and Paths

### QFile and QIODevice
- Use `QFile` for file operations
- Check `open()` return value and handle errors
- Use RAII: `QFile` auto-closes in destructor
- Use `QTextStream` or `QDataStream` for formatted I/O

### Path Handling
- Use `QDir` and `QFileInfo` for path operations
- Use `QDir::separator()` for platform-independent paths
- Use `QStandardPaths` for standard directories (Documents, AppData, etc.)
- Prefer forward slashes in code; Qt normalizes automatically

## Internationalization (i18n)

### Translation Strings
- Wrap user-visible strings with `tr()`:
  ```cpp
  QString message = tr("Document opened successfully");
  ```
- Use `tr()` with context for disambiguation:
  ```cpp
  QString text = tr("File", "menu item");
  ```

### Translation Files
- Translation files are in [app/i18n/](mdc:app/i18n/): `app_en.ts`, `app_zh.ts`
- Use Qt Linguist tools: `lupdate` to extract, `lrelease` to compile
- Load translations with `QTranslator` in main:
  ```cpp
  QTranslator translator;
  translator.load(":/i18n/app_" + QLocale::system().name());
  app.installTranslator(&translator);
  ```

### I18nManager
- Project uses [I18nManager](mdc:app/managers/I18nManager.h) for runtime language switching
- Emit `languageChanged()` signal to update UI

## Performance Best Practices

### Avoid Expensive Operations in GUI Thread
- Use `QTimer::singleShot(0, ...)` to defer work
- Move heavy operations to background threads
- Use progress dialogs for long operations

### Minimize Repaints
- Use `update()` to schedule paint, not immediate repaint
- Use `repaint()` only when immediate update is required
- Update only affected regions: `update(rect)`

### Object Reuse
- Reuse objects instead of recreating (e.g., `QImage` buffers)
- Use object pools for frequently created/destroyed objects
- Cache computed values

### String Handling
- Use `QStringLiteral()` for compile-time string constants:
  ```cpp
  const QString KEY = QStringLiteral("myKey");
  ```
- Use `QLatin1String` for Latin-1 literals in comparisons
- Avoid repeated `QString` allocations in loops

## Qt Creator Integration

### UI Files (.ui)
- Use Qt Designer for complex layouts
- Load with `QUiLoader` or generate code with `uic`
- Access widgets: `ui->widgetName`

### Signals and Slots in Designer
- Connect signals/slots visually in Designer
- Auto-connects slots named `on_widgetName_signalName()`
- Prefer code connections for clarity and refactorability

## Debugging Qt Applications

### qDebug() and Logging
- Use project's logging system, not `qDebug()` directly
- See [app/logging/](mdc:app/logging/) for logging infrastructure
- Use Qt's message handler for Qt internal messages

### Object Inspection
- Use `objectName()` property for debugging widget hierarchy
- Use `dumpObjectTree()` and `dumpObjectInfo()` in debug builds

### Qt Tools
- Use Qt Creator's debugger extensions for Qt types
- Use GammaRay for runtime Qt object inspection
